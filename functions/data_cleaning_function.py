# -*- coding: utf-8 -*-
"""Data_Cleaning_Function

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PVLS3YOfUHq62EyFWmUUDBDKnKwnHyuo
"""

#important necessary modules
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colormaps as cmap

"""# Load in Data

Before loading in our data, we wanted to find the shared questions (features) across all years. Using the 2016 csv OSMI dataset, we assigned an integer to each question. For each question from 2016, we went through the 2017-2021 datasets to find questions that asked the same things (even if the wording was slightly different) and assigned shared questions across all years the same integer. If a question did not appear in all years from 2016-2021 surveys, that question did not get assigned an integer. A row containing these integers was added as the first row in each year's dataset.

"""

# load in raw data csv's updated with row containing number labels

#'2016datafilepath' is a placeholder for the path to the 2016updated CSV file as it appears on your computer
df2016Updated = pd.read_csv('2016datafilepath.csv')

#'2017datafilepath' is a placeholder for the path to the 2017updated CSV file as it appears on your computer
df2017Updated = pd.read_csv('2017datafilepath.csv')

#'2018datafilepath' is a placeholder for the path to the 2018updated CSV file as it appears on your computer
df2018Updated = pd.read_csv('2018datafilepath.csv')

#'2019datafilepath' is a placeholder for the path to the 2019updated CSV file as it appears on your computer
df2019Updated = pd.read_csv('2019datafilepath.csv')

#'2020datafilepath' is a placeholder for the path to the 2020updated CSV file as it appears on your computer
df2020Updated = pd.read_csv('2020datafilepath.csv')

#'2021datafilepath' is a placeholder for the path to the 2021updated CSV file as it appears on your computer
df2021Updated = pd.read_csv('2021datafilepath.csv')

"""# Filter Out Features Function

For each year's dataset, we need a function that filters out features that contain null values in the first row (i.e., meaning the question did not appear in all years). 
"""

def filterFeatures(df):
  """
    Input: pandas dataframe
    This function filters out features that contain null values in the first row (i.e., the number label row)
    Output: pandas dataframe with features filtered out
  """

  colsWithNull = df.columns[df.iloc[0].isnull()] #find features that contain a null value in the first row of input df
  df = df.drop(colsWithNull, axis=1) #drop those features
  return df

"""# Rename Columns Function

We want to concatenate dataframes vertically so that columns representing the same question from different years are stacked on top of one another. To do this, we need the column names across the different years' dataframes to match, so we made a function to use the integer labels as the new column headings

```
# This is formatted as code
```

. 

"""

def renameColHeaders(df):

  """
  Input: pandas dataframe with columns named as survey questions
  This function takes in a pandas dataframe and replaces the column headers containing survey questions with integers that we assigned to corresponding survey questions.
  Output: pandas dataframe with columns renamed to integer labels
  """

  df = df.rename(columns=df.iloc[0]).drop(df.index[0]) #renames columns to integers 
  df.columns = df.columns.astype(int) #makes all new column headers integer data values (some might've been string or floats)
  return df

"""# Make Combined Matrix
We need a function that calls the filtering and renaming functions to clean each year's raw dataframe and standardize the feature names across all years. This will allow us to concatenate all the dataframes into one combined matrix. Additionally, from data exploration, we observed that the question asking, "What is your gender?", is actually an open-ended question. However, because it asks about an essential piece of demographic information, we want to include it in our dataset for future modeling. Before we can vectorize this feature (column 54), we categorized each response as "male", "female", and "other".
"""

def makeTextMatrix(df2016, df2017, df2018, df2019, df2020, df2021):

  """
  Input: 6 pandas dataframe representing raw survey data from each year between 2016-2021
  This function takes in each year's data in a pandas dataframe, filters out features that don't appear across all 6 years for each dataframe, and renames the remaining features in each dataframe to a standardized name. It then concatenates the 6 dataframes vertically. After concatenation, we sort the open-ended responses in the "What is your gender?" feature into three categories: "male", "female", or "other".
  Output: concatenated pandas dataframe with columns renamed to integer labels and a fixed gender column
  """
  #for 2016 dataframe, we are filtering out features not shared throughout all years and renaming remaning features 
  df2016Filtered = filterFeatures(df2016Updated)
  df2016Renamed = renameColHeaders(df2016Updated)

  #for 2017 dataframe, we are filtering out features not shared throughout all years and renaming remaning features 
  df2017Filtered = filterFeatures(df2017Updated)
  df2017Renamed  = renameColHeaders(df2017Updated)

  #for 2018 dataframe, we are filtering out features not shared throughout all years and renaming remaning features 
  df2018Filtered = filterFeatures(df2018Updated)
  df2018Renamed  = renameColHeaders(df2018Updated)

  #for 2019 dataframe, we are filtering out features not shared throughout all years and renaming remaning features 
  df2019Filtered = filterFeatures(df2019Updated)
  df2019Renamed  = renameColHeaders(df2019Updated)

  #for 2020 dataframe, we are filtering out features not shared throughout all years and renaming remaning features 
  df2020Filtered = filterFeatures(df2020Updated)
  df2020Renamed  = renameColHeaders(df2020Updated)

  #for 2021 dataframe, we are filtering out features not shared throughout all years and renaming remaning features 
  df2021Filtered = filterFeatures(df2021Updated)
  df2021Renamed  = renameColHeaders(df2021Updated)

  #with column names standardized across all the years, we can now concatenate the dataframes vertically
  dfCombined = pd.concat([df2016Renamed, df2017Renamed, df2018Renamed, df2019Renamed, df2020Renamed, df2021Renamed], axis=0)

  #fixing the gender column
  #we went through all responses in the "What is your gender?" feature to categorize them as either male or female
  male = ["male", "m", "male-ish", "maile", "mal", "male (cis)", "make", "male ", "man","msle", "mail", "malr","cis man", "cis male"]
  female = ["cis female", "f", "female", "woman",  "femake", "female ","cis-female/femme", "female (cis)", "femail"]
  # other = ["trans-female", "something kinda male?", "queer/she/they", "non-binary","nah", "all", "enby", "fluid", 
  #          "genderqueer", "androgyne", "agender", "male leaning androgynous", "guy (-ish) ^_^", "trans woman", "neuter", 
  #          "female (trans)", "queer", "ostensibly male, unsure what that really means", "p", "a little about you"]

  #changing responses to the gender question to either male or female depending on which gender category the response falls under
  dfCombined[54].loc[dfCombined[54].isin(male)] = 'male'
  dfCombined[54].loc[dfCombined[54].isin(female)] = 'female'

  #any other response that doesn't fall under the "male" or "female" category is labeled as "other"
  dfCombined[54] = dfCombined[54].apply(lambda x: 'other' if (x != "male" and x != "female") else x)

  return dfCombined

"""# Filter Out Features with Too Many Null Values

Now that we have our combined dataframe, we want to make sure our features have enough data in them to be useful in our future models. We made a function to determine that if a feature has at least 70% non-null values, we will keep it.
"""

def filterNull(dfCombined):
  """
  Input: combined text dataframe from makeTextMatrix function
  This function filters out features that have more than 30% null values.
  Output: combined text dataframe with features that have at least 70% non null values
  """
  nullPerc = dfCombined.isnull().sum() / len(dfCombined) #calculate percentage of NA values in each feature
  nonNullPerc = 1-nullPerc #subtract that percentage from 1 to calculate percentage of non-null values in each feature
  colsToKeep = nonNullPerc[nonNullPerc > 0.7].index.tolist() #designate feature as one to keep if more than 70% of its values are non-null data that we can actually use
  dfCombinedFinal = dfCombined[colsToKeep] #only keep features with at least 70% non-null values from combined dataframe

  return dfCombinedFinal